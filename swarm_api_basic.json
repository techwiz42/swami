{
  "name": "swarm",
  "classes": {
    "Agent": {
      "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "methods": {
        "construct": {
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "doc": null
        },
        "copy": {
          "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
          "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
        },
        "dict": {
          "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
          "doc": null
        },
        "from_orm": {
          "signature": "(obj: 'Any') -> 'Self'",
          "doc": null
        },
        "json": {
          "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
          "doc": null
        },
        "model_construct": {
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "doc": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data."
        },
        "model_copy": {
          "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
        },
        "model_dump": {
          "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
        },
        "model_dump_json": {
          "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
        },
        "model_json_schema": {
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
        },
        "model_parametrized_name": {
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
        },
        "model_post_init": {
          "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
          "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
        },
        "model_rebuild": {
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
        },
        "model_validate": {
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
          "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
        },
        "model_validate_json": {
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
        },
        "model_validate_strings": {
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
          "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
        },
        "parse_file": {
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "doc": null
        },
        "parse_obj": {
          "signature": "(obj: 'Any') -> 'Self'",
          "doc": null
        },
        "parse_raw": {
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "doc": null
        },
        "schema": {
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "doc": null
        },
        "schema_json": {
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "doc": null
        },
        "update_forward_refs": {
          "signature": "(**localns: 'Any') -> 'None'",
          "doc": null
        },
        "validate": {
          "signature": "(value: 'Any') -> 'Self'",
          "doc": null
        }
      }
    },
    "Response": {
      "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
      "methods": {
        "construct": {
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "doc": null
        },
        "copy": {
          "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
          "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
        },
        "dict": {
          "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
          "doc": null
        },
        "from_orm": {
          "signature": "(obj: 'Any') -> 'Self'",
          "doc": null
        },
        "json": {
          "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
          "doc": null
        },
        "model_construct": {
          "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
          "doc": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data."
        },
        "model_copy": {
          "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
        },
        "model_dump": {
          "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
        },
        "model_dump_json": {
          "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
        },
        "model_json_schema": {
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
          "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
        },
        "model_parametrized_name": {
          "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
          "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
        },
        "model_post_init": {
          "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
          "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
        },
        "model_rebuild": {
          "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
          "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
        },
        "model_validate": {
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
          "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
        },
        "model_validate_json": {
          "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
        },
        "model_validate_strings": {
          "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
          "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
        },
        "parse_file": {
          "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "doc": null
        },
        "parse_obj": {
          "signature": "(obj: 'Any') -> 'Self'",
          "doc": null
        },
        "parse_raw": {
          "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
          "doc": null
        },
        "schema": {
          "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
          "doc": null
        },
        "schema_json": {
          "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
          "doc": null
        },
        "update_forward_refs": {
          "signature": "(**localns: 'Any') -> 'None'",
          "doc": null
        },
        "validate": {
          "signature": "(value: 'Any') -> 'Self'",
          "doc": null
        }
      }
    },
    "Swarm": {
      "doc": null,
      "methods": {
        "get_chat_completion": {
          "signature": "(self, agent: swarm.types.Agent, history: List, context_variables: dict, model_override: str, stream: bool, debug: bool) -> openai.types.chat.chat_completion_message.ChatCompletionMessage",
          "doc": null
        },
        "handle_function_result": {
          "signature": "(self, result, debug) -> swarm.types.Result",
          "doc": null
        },
        "handle_tool_calls": {
          "signature": "(self, tool_calls: List[openai.types.chat.chat_completion_message_tool_call.ChatCompletionMessageToolCall], functions: List[Callable[[], Union[str, ForwardRef('Agent'), dict]]], context_variables: dict, debug: bool) -> swarm.types.Response",
          "doc": null
        },
        "run": {
          "signature": "(self, agent: swarm.types.Agent, messages: List, context_variables: dict = {}, model_override: str = None, stream: bool = False, debug: bool = False, max_turns: int = inf, execute_tools: bool = True) -> swarm.types.Response",
          "doc": null
        },
        "run_and_stream": {
          "signature": "(self, agent: swarm.types.Agent, messages: List, context_variables: dict = {}, model_override: str = None, debug: bool = False, max_turns: int = inf, execute_tools: bool = True)",
          "doc": null
        }
      }
    }
  },
  "submodules": {
    "core": {
      "name": "swarm.core",
      "classes": {
        "Agent": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data."
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "ChatCompletionMessage": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "to_dict": {
              "signature": "(self, *, mode: \"Literal['json', 'python']\" = 'python', use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'dict[str, object]'",
              "doc": "Recursively generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    mode:\n        If mode is 'json', the dictionary will only contain JSON serializable types. e.g. `datetime` will be turned into a string, `\"2024-3-22T18:11:19.117000Z\"`.\n        If mode is 'python', the dictionary may contain any Python objects. e.g. `datetime(2024, 3, 22)`\n\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value from the output.\n    exclude_none: Whether to exclude fields that have a value of `None` from the output.\n    warnings: Whether to log warnings when invalid fields are encountered. This is only supported in Pydantic v2."
            },
            "to_json": {
              "signature": "(self, *, indent: 'int | None' = 2, use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'str'",
              "doc": "Generates a JSON string representing this model as it would be received from or sent to the API (but with indentation).\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    indent: Indentation to use in the JSON output. If `None` is passed, the output will be compact. Defaults to `2`\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that have the default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    warnings: Whether to show any warnings that occurred during serialization. This is only supported in Pydantic v2."
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "ChatCompletionMessageToolCall": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "to_dict": {
              "signature": "(self, *, mode: \"Literal['json', 'python']\" = 'python', use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'dict[str, object]'",
              "doc": "Recursively generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    mode:\n        If mode is 'json', the dictionary will only contain JSON serializable types. e.g. `datetime` will be turned into a string, `\"2024-3-22T18:11:19.117000Z\"`.\n        If mode is 'python', the dictionary may contain any Python objects. e.g. `datetime(2024, 3, 22)`\n\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value from the output.\n    exclude_none: Whether to exclude fields that have a value of `None` from the output.\n    warnings: Whether to log warnings when invalid fields are encountered. This is only supported in Pydantic v2."
            },
            "to_json": {
              "signature": "(self, *, indent: 'int | None' = 2, use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'str'",
              "doc": "Generates a JSON string representing this model as it would be received from or sent to the API (but with indentation).\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    indent: Indentation to use in the JSON output. If `None` is passed, the output will be compact. Defaults to `2`\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that have the default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    warnings: Whether to show any warnings that occurred during serialization. This is only supported in Pydantic v2."
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "Function": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "to_dict": {
              "signature": "(self, *, mode: \"Literal['json', 'python']\" = 'python', use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'dict[str, object]'",
              "doc": "Recursively generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    mode:\n        If mode is 'json', the dictionary will only contain JSON serializable types. e.g. `datetime` will be turned into a string, `\"2024-3-22T18:11:19.117000Z\"`.\n        If mode is 'python', the dictionary may contain any Python objects. e.g. `datetime(2024, 3, 22)`\n\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value from the output.\n    exclude_none: Whether to exclude fields that have a value of `None` from the output.\n    warnings: Whether to log warnings when invalid fields are encountered. This is only supported in Pydantic v2."
            },
            "to_json": {
              "signature": "(self, *, indent: 'int | None' = 2, use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'str'",
              "doc": "Generates a JSON string representing this model as it would be received from or sent to the API (but with indentation).\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    indent: Indentation to use in the JSON output. If `None` is passed, the output will be compact. Defaults to `2`\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that have the default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    warnings: Whether to show any warnings that occurred during serialization. This is only supported in Pydantic v2."
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "OpenAI": {
          "doc": "Abstract base class for generic types.\n\nA generic type is typically declared by inheriting from\nthis class parameterized with one or more type variables.\nFor example, a generic mapping type might be defined as::\n\n  class Mapping(Generic[KT, VT]):\n      def __getitem__(self, key: KT) -> VT:\n          ...\n      # Etc.\n\nThis class can then be used as follows::\n\n  def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n      try:\n          return mapping[key]\n      except KeyError:\n          return default",
          "methods": {
            "close": {
              "signature": "(self) -> 'None'",
              "doc": "Close the underlying HTTPX client.\n\nThe client will *not* be usable after this."
            },
            "copy": {
              "signature": "(self, *, api_key: 'str | None' = None, organization: 'str | None' = None, project: 'str | None' = None, websocket_base_url: 'str | httpx.URL | None' = None, base_url: 'str | httpx.URL | None' = None, timeout: 'float | Timeout | None | NotGiven' = NOT_GIVEN, http_client: 'httpx.Client | None' = None, max_retries: 'int | NotGiven' = NOT_GIVEN, default_headers: 'Mapping[str, str] | None' = None, set_default_headers: 'Mapping[str, str] | None' = None, default_query: 'Mapping[str, object] | None' = None, set_default_query: 'Mapping[str, object] | None' = None, _extra_kwargs: 'Mapping[str, Any]' = {}) -> 'Self'",
              "doc": "Create a new client instance re-using the same options given to the current client with optional overriding."
            },
            "delete": {
              "signature": "(self, path: 'str', *, cast_to: 'Type[ResponseT]', body: 'Body | None' = None, options: 'RequestOptions' = {}) -> 'ResponseT'",
              "doc": null
            },
            "get": {
              "signature": "(self, path: 'str', *, cast_to: 'Type[ResponseT]', options: 'RequestOptions' = {}, stream: 'bool' = False, stream_cls: 'type[_StreamT] | None' = None) -> 'ResponseT | _StreamT'",
              "doc": null
            },
            "get_api_list": {
              "signature": "(self, path: 'str', *, model: 'Type[object]', page: 'Type[SyncPageT]', body: 'Body | None' = None, options: 'RequestOptions' = {}, method: 'str' = 'get') -> 'SyncPageT'",
              "doc": null
            },
            "is_closed": {
              "signature": "(self) -> 'bool'",
              "doc": null
            },
            "patch": {
              "signature": "(self, path: 'str', *, cast_to: 'Type[ResponseT]', body: 'Body | None' = None, options: 'RequestOptions' = {}) -> 'ResponseT'",
              "doc": null
            },
            "platform_headers": {
              "signature": "(self) -> 'Dict[str, str]'",
              "doc": null
            },
            "post": {
              "signature": "(self, path: 'str', *, cast_to: 'Type[ResponseT]', body: 'Body | None' = None, options: 'RequestOptions' = {}, files: 'RequestFiles | None' = None, stream: 'bool' = False, stream_cls: 'type[_StreamT] | None' = None) -> 'ResponseT | _StreamT'",
              "doc": null
            },
            "put": {
              "signature": "(self, path: 'str', *, cast_to: 'Type[ResponseT]', body: 'Body | None' = None, files: 'RequestFiles | None' = None, options: 'RequestOptions' = {}) -> 'ResponseT'",
              "doc": null
            },
            "request": {
              "signature": "(self, cast_to: 'Type[ResponseT]', options: 'FinalRequestOptions', remaining_retries: 'Optional[int]' = None, *, stream: 'bool' = False, stream_cls: 'type[_StreamT] | None' = None) -> 'ResponseT | _StreamT'",
              "doc": null
            },
            "with_options": {
              "signature": "(self, *, api_key: 'str | None' = None, organization: 'str | None' = None, project: 'str | None' = None, websocket_base_url: 'str | httpx.URL | None' = None, base_url: 'str | httpx.URL | None' = None, timeout: 'float | Timeout | None | NotGiven' = NOT_GIVEN, http_client: 'httpx.Client | None' = None, max_retries: 'int | NotGiven' = NOT_GIVEN, default_headers: 'Mapping[str, str] | None' = None, set_default_headers: 'Mapping[str, str] | None' = None, default_query: 'Mapping[str, object] | None' = None, set_default_query: 'Mapping[str, object] | None' = None, _extra_kwargs: 'Mapping[str, Any]' = {}) -> 'Self'",
              "doc": "Create a new client instance re-using the same options given to the current client with optional overriding."
            }
          }
        },
        "Response": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data."
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "Result": {
          "doc": "Encapsulates the possible return values for an agent function.\n\nAttributes:\n    value (str): The result value as a string.\n    agent (Agent): The agent instance, if applicable.\n    context_variables (dict): A dictionary of context variables.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data."
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "Swarm": {
          "doc": null,
          "methods": {
            "get_chat_completion": {
              "signature": "(self, agent: swarm.types.Agent, history: List, context_variables: dict, model_override: str, stream: bool, debug: bool) -> openai.types.chat.chat_completion_message.ChatCompletionMessage",
              "doc": null
            },
            "handle_function_result": {
              "signature": "(self, result, debug) -> swarm.types.Result",
              "doc": null
            },
            "handle_tool_calls": {
              "signature": "(self, tool_calls: List[openai.types.chat.chat_completion_message_tool_call.ChatCompletionMessageToolCall], functions: List[Callable[[], Union[str, ForwardRef('Agent'), dict]]], context_variables: dict, debug: bool) -> swarm.types.Response",
              "doc": null
            },
            "run": {
              "signature": "(self, agent: swarm.types.Agent, messages: List, context_variables: dict = {}, model_override: str = None, stream: bool = False, debug: bool = False, max_turns: int = inf, execute_tools: bool = True) -> swarm.types.Response",
              "doc": null
            },
            "run_and_stream": {
              "signature": "(self, agent: swarm.types.Agent, messages: List, context_variables: dict = {}, model_override: str = None, debug: bool = False, max_turns: int = inf, execute_tools: bool = True)",
              "doc": null
            }
          }
        },
        "defaultdict": {
          "doc": "defaultdict(default_factory=None, /, [...]) --> dict with default factory\n\nThe default factory is called without arguments to produce\na new value when a key is not present, in __getitem__ only.\nA defaultdict compares equal to a dict with the same items.\nAll remaining arguments are treated the same as if they were\npassed to the dict constructor, including keyword arguments.",
          "methods": {}
        }
      },
      "submodules": {}
    },
    "types": {
      "name": "swarm.types",
      "classes": {
        "Agent": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data."
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "BaseModel": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data."
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "ChatCompletionMessage": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "to_dict": {
              "signature": "(self, *, mode: \"Literal['json', 'python']\" = 'python', use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'dict[str, object]'",
              "doc": "Recursively generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    mode:\n        If mode is 'json', the dictionary will only contain JSON serializable types. e.g. `datetime` will be turned into a string, `\"2024-3-22T18:11:19.117000Z\"`.\n        If mode is 'python', the dictionary may contain any Python objects. e.g. `datetime(2024, 3, 22)`\n\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value from the output.\n    exclude_none: Whether to exclude fields that have a value of `None` from the output.\n    warnings: Whether to log warnings when invalid fields are encountered. This is only supported in Pydantic v2."
            },
            "to_json": {
              "signature": "(self, *, indent: 'int | None' = 2, use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'str'",
              "doc": "Generates a JSON string representing this model as it would be received from or sent to the API (but with indentation).\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    indent: Indentation to use in the JSON output. If `None` is passed, the output will be compact. Defaults to `2`\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that have the default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    warnings: Whether to show any warnings that occurred during serialization. This is only supported in Pydantic v2."
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "ChatCompletionMessageToolCall": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "to_dict": {
              "signature": "(self, *, mode: \"Literal['json', 'python']\" = 'python', use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'dict[str, object]'",
              "doc": "Recursively generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    mode:\n        If mode is 'json', the dictionary will only contain JSON serializable types. e.g. `datetime` will be turned into a string, `\"2024-3-22T18:11:19.117000Z\"`.\n        If mode is 'python', the dictionary may contain any Python objects. e.g. `datetime(2024, 3, 22)`\n\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value from the output.\n    exclude_none: Whether to exclude fields that have a value of `None` from the output.\n    warnings: Whether to log warnings when invalid fields are encountered. This is only supported in Pydantic v2."
            },
            "to_json": {
              "signature": "(self, *, indent: 'int | None' = 2, use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'str'",
              "doc": "Generates a JSON string representing this model as it would be received from or sent to the API (but with indentation).\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    indent: Indentation to use in the JSON output. If `None` is passed, the output will be compact. Defaults to `2`\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that have the default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    warnings: Whether to show any warnings that occurred during serialization. This is only supported in Pydantic v2."
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "Function": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'object') -> 'ModelT'",
              "doc": null
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "to_dict": {
              "signature": "(self, *, mode: \"Literal['json', 'python']\" = 'python', use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'dict[str, object]'",
              "doc": "Recursively generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    mode:\n        If mode is 'json', the dictionary will only contain JSON serializable types. e.g. `datetime` will be turned into a string, `\"2024-3-22T18:11:19.117000Z\"`.\n        If mode is 'python', the dictionary may contain any Python objects. e.g. `datetime(2024, 3, 22)`\n\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value from the output.\n    exclude_none: Whether to exclude fields that have a value of `None` from the output.\n    warnings: Whether to log warnings when invalid fields are encountered. This is only supported in Pydantic v2."
            },
            "to_json": {
              "signature": "(self, *, indent: 'int | None' = 2, use_api_names: 'bool' = True, exclude_unset: 'bool' = True, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, warnings: 'bool' = True) -> 'str'",
              "doc": "Generates a JSON string representing this model as it would be received from or sent to the API (but with indentation).\n\nBy default, fields that were not set by the API will not be included,\nand keys will match the API response, *not* the property names from the model.\n\nFor example, if the API responds with `\"fooBar\": true` but we've defined a `foo_bar: bool` property,\nthe output will use the `\"fooBar\"` key (unless `use_api_names=False` is passed).\n\nArgs:\n    indent: Indentation to use in the JSON output. If `None` is passed, the output will be compact. Defaults to `2`\n    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that have the default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    warnings: Whether to show any warnings that occurred during serialization. This is only supported in Pydantic v2."
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "Response": {
          "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/models/\n\nA base class for creating Pydantic models.\n\nAttributes:\n    __class_vars__: The names of the class variables defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The core schema of the model.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n    __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n    __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n    __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n    __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n        is set to `'allow'`.\n    __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n    __pydantic_private__: Values of private attributes set on the model instance.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data."
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        },
        "Result": {
          "doc": "Encapsulates the possible return values for an agent function.\n\nAttributes:\n    value (str): The result value as a string.\n    agent (Agent): The agent instance, if applicable.\n    context_variables (dict): A dictionary of context variables.",
          "methods": {
            "construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": null
            },
            "copy": {
              "signature": "(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Returns a copy of the model.\n\n!!! warning \"Deprecated\"\n    This method is now deprecated; use `model_copy` instead.\n\nIf you need `include` or `exclude`, use:\n\n```python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n```\n\nArgs:\n    include: Optional set or mapping specifying which fields to include in the copied model.\n    exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n    update: Optional dictionary of field-value pairs to override field values in the copied model.\n    deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns:\n    A copy of the model with included, excluded and updated fields as specified."
            },
            "dict": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'",
              "doc": null
            },
            "from_orm": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "json": {
              "signature": "(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "model_construct": {
              "signature": "(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'",
              "doc": "Creates a new instance of the `Model` class with validated data.\n\nCreates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n    `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n    That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n    and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n    Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n    an error if extra values are passed, but they will be ignored.\n\nArgs:\n    _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n        this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n        Otherwise, the field names from the `values` argument will be used.\n    values: Trusted or pre-validated data dictionary.\n\nReturns:\n    A new instance of the `Model` class with validated data."
            },
            "model_copy": {
              "signature": "(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nArgs:\n    update: Values to change/add in the new model. Note: the data is not validated\n        before creating the new model. You should trust this data.\n    deep: Set to `True` to make a deep copy of the model.\n\nReturns:\n    New model instance."
            },
            "model_dump": {
              "signature": "(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nArgs:\n    mode: The mode in which `to_python` should run.\n        If mode is 'json', the output will only contain JSON serializable types.\n        If mode is 'python', the output may contain non-JSON-serializable Python objects.\n    include: A set of fields to include in the output.\n    exclude: A set of fields to exclude from the output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to use the field's alias in the dictionary key if defined.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A dictionary representation of the model."
            },
            "model_dump_json": {
              "signature": "(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, serialize_as_any: 'bool' = False) -> 'str'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic's `to_json` method.\n\nArgs:\n    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n    include: Field(s) to include in the JSON output.\n    exclude: Field(s) to exclude from the JSON output.\n    context: Additional context to pass to the serializer.\n    by_alias: Whether to serialize using field aliases.\n    exclude_unset: Whether to exclude fields that have not been explicitly set.\n    exclude_defaults: Whether to exclude fields that are set to their default value.\n    exclude_none: Whether to exclude fields that have a value of `None`.\n    round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n    warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n        \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n    serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\nReturns:\n    A JSON string representation of the model."
            },
            "model_json_schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation') -> 'dict[str, Any]'",
              "doc": "Generates a JSON schema for a model class.\n\nArgs:\n    by_alias: Whether to use attribute aliases or not.\n    ref_template: The reference template.\n    schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n        `GenerateJsonSchema` with your desired modifications\n    mode: The mode in which to generate the schema.\n\nReturns:\n    The JSON schema for the given model class."
            },
            "model_parametrized_name": {
              "signature": "(params: 'tuple[type[Any], ...]') -> 'str'",
              "doc": "Compute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nArgs:\n    params: Tuple of types of the class. Given a generic class\n        `Model` with 2 type variables and a concrete model `Model[str, int]`,\n        the value `(str, int)` would be passed to `params`.\n\nReturns:\n    String representing the new class where `params` are passed to `cls` as type variables.\n\nRaises:\n    TypeError: Raised when trying to generate concrete names for non-generic models."
            },
            "model_post_init": {
              "signature": "(self, _BaseModel__context: 'Any') -> 'None'",
              "doc": "Override this method to perform additional initialization after `__init__` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
            },
            "model_rebuild": {
              "signature": "(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'",
              "doc": "Try to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nArgs:\n    force: Whether to force the rebuilding of the model schema, defaults to `False`.\n    raise_errors: Whether to raise errors, defaults to `True`.\n    _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n    _types_namespace: The types namespace, defaults to `None`.\n\nReturns:\n    Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n    If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`."
            },
            "model_validate": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate a pydantic model instance.\n\nArgs:\n    obj: The object to validate.\n    strict: Whether to enforce types strictly.\n    from_attributes: Whether to extract data from object attributes.\n    context: Additional context to pass to the validator.\n\nRaises:\n    ValidationError: If the object could not be validated.\n\nReturns:\n    The validated model instance."
            },
            "model_validate_json": {
              "signature": "(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nArgs:\n    json_data: The JSON data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model.\n\nRaises:\n    ValidationError: If `json_data` is not a JSON string or the object could not be validated."
            },
            "model_validate_strings": {
              "signature": "(obj: 'Any', *, strict: 'bool | None' = None, context: 'Any | None' = None) -> 'Self'",
              "doc": "Validate the given object with string data against the Pydantic model.\n\nArgs:\n    obj: The object containing string data to validate.\n    strict: Whether to enforce types strictly.\n    context: Extra variables to pass to the validator.\n\nReturns:\n    The validated Pydantic model."
            },
            "parse_file": {
              "signature": "(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "parse_obj": {
              "signature": "(obj: 'Any') -> 'Self'",
              "doc": null
            },
            "parse_raw": {
              "signature": "(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'",
              "doc": null
            },
            "schema": {
              "signature": "(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'",
              "doc": null
            },
            "schema_json": {
              "signature": "(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'",
              "doc": null
            },
            "update_forward_refs": {
              "signature": "(**localns: 'Any') -> 'None'",
              "doc": null
            },
            "validate": {
              "signature": "(value: 'Any') -> 'Self'",
              "doc": null
            }
          }
        }
      },
      "submodules": {}
    },
    "util": {
      "name": "swarm.util",
      "classes": {
        "datetime": {
          "doc": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\nThe year, month and day arguments are required. tzinfo may be None, or an\ninstance of a tzinfo subclass. The remaining arguments may be ints.",
          "methods": {}
        }
      },
      "submodules": {}
    }
  }
}